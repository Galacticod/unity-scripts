using UnityEngine;
using System.Collections;


[RequireComponent(typeof(Steer))]
[RequireComponent(typeof(CharacterController))]


public class Flocker : MonoBehaviour {

//movement variables - exposed in inspector panel

	private GameManager gm;
	//reference to an array of obstacles
	private  GameObject[] obstacles; 
	
	
	// These weights will be exposed in the Inspector window

	
	public float gravity = 10.0f;  
	
	// Each vehicle contains a CharacterController which helps to deal with
	// the relationship between movement initiated by the character and the forces
	// generated by contact with the terrain & other game objects.
	private CharacterController characterController;
	
	// the SteeringAttributes holds several variables needed for steering
	private SteeringAttributes steeringAtt;

	// the Steer component implements the basic steering functions
	private Steer steer;

	private Vector3 acceleration;	//change in velocity per second
	private Vector3 velocity;		//change in position per second
	public Vector3 Velocity {
		get { return velocity; }
		set { velocity = value;}
	}

	private string fishColor;
	public string FishColor  { 	
		get {return fishColor; } 
		set {fishColor = value; }	
	}

	void Start ()
	{
		acceleration = Vector3.zero;
		velocity = transform.forward;
		obstacles = GameObject.FindGameObjectsWithTag ("Obstacle");	

		//get component references
		characterController = gameObject.GetComponent<CharacterController> ();
		steer = gameObject.GetComponent<Steer> ();
		steeringAtt = GameObject.Find("MainGO").GetComponent<SteeringAttributes> ();
		gm = GameObject.Find("MainGO").GetComponent<GameManager>();
	}
	
	void Update ()
	{
		CalcSteeringForce ();

		//ugly kludge to adjust behavior for 3 kinds of fish
		float maxSp = steeringAtt.maxSpeed;
		if(fishColor == "red") {
			maxSp *= 0.8f;

		} else if (fishColor == "blue") {
			maxSp *=  1.8f;

		}  

		//update velocity
		velocity += acceleration * Time.deltaTime;
		velocity.y = 0;	// we are staying in the x/z plane more or less
		velocity = Vector3.ClampMagnitude (velocity, maxSp);
		
		//orient the transform to face where we going
		if (velocity != Vector3.zero)
			transform.forward = velocity.normalized;

		// keep us in a vertical range
//		float ypos = Terrain.activeTerrain.SampleHeight(transform.position);  
//		Debug.Log( "ypos:"+ypos+ ", y "+ transform.position.y +" -- diff: "+(transform.position.y-ypos));
//		if (ypos > 15 ) 
//		{
//			velocity.y -= gravity * Time.deltaTime;
//		}
//		else if (ypos < 10 ) velocity.y += gravity * Time.deltaTime;
		// the CharacterController moves us subject to physical constraints
		characterController.Move (velocity * Time.deltaTime);
		
		//reset acceleration for next cycle
		acceleration = Vector3.zero;
	}
	
	
	//calculate and apply steering forces
	private void CalcSteeringForce ()
	{ 
		Vector3 force = Vector3.zero;

		//obstacles
		for (int i=0; i<obstacles.Length; i++)
		{	
			force += steeringAtt.avoidWt * steer.AvoidObstacle (obstacles[i], steeringAtt.avoidDist);
		}
		Debug.DrawRay (transform.position, force, Color.cyan);
	
		//in bounds
		//first parameter in stayInBounds determines distance fish can swim from original spawn point------------------------------------------------------------
		force += steeringAtt.inBoundsWt * steer.StayInBounds (90, new Vector3(0,0,0));
		
		if (force.sqrMagnitude < 5000) 
		{

			//ugly kludge to adjust behavior for 3 kinds of fish
			float alWt = (float)steeringAtt.alignmentWt;
			float coWt = (float)steeringAtt.cohesionWt;
			float centerWt = (float)steeringAtt.centerWt;
			if(fishColor == "red"){
				alWt *= 1.5f;
				coWt *= 0.8f;
			} else if (fishColor == "blue") {
				alWt *= 2f;
				coWt *= 1.2f;
			} 

			force += steeringAtt.separationWt * steer.Separate (gm.FlockList);
						
			force += alWt * steer.Align(gm.FlockDirections[fishColor]); 
			
			force += coWt * steer.Cohere(gm.Centroids[fishColor]);

			force += centerWt * steer.Seek(Vector3.zero);
		}
	 
		
		force = Vector3.ClampMagnitude (force, steeringAtt.maxForce);
		//force.y = 0;
		ApplyForce(force);
	}

	
	private void ApplyForce (Vector3 steeringForce)
	{
		acceleration += steeringForce/steeringAtt.mass;
	}
}
